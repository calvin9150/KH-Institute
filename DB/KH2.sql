SELECT * FROM DBA_USERS; --현재 데이터베이스에 등록된 계정들을 조회하는 명령어
--기본적인 명령어 실행하려면 명령어(쿼리문) 작성 라인에 커서를 두고 CTRL+ENTER
--오라클DB는 기본적으론 명령어를 1개씩 실행한다. 
SELECT*FROM TAB; --현재 계정에 들록된 테이블을 조회

-- ..? 무슨 비번 안먹힐때 무슨 무슨 방법
SELECT * FROM DBA_USERS;
-- 비밀번호 변경하면 됨.
ALTER USER TEST IDENTIFIED BY TEST;

--위에서 이용한 쿼리문은 오라클이 이용자에게 DB정보를 제공하기 위해 만든 가상의 테이블 -> DATA DICTIONARY
--오라클은 기본적으로 DB관리자 계정을 자동으로 부여함
--SYSTEM : 일반관리자 계정 -> DB를 생성 및 삭제할 관리는 없다. 사용자계정 등록 및 권한부여 역할
--SYS : 수퍼관리자 계정 -> DB 생성 및 삭제 가능, 사용자계정 등록 및 권한부여도 가능
--SYS AS SYSDBA : 수퍼관리자 계정으로 접속

--기본적으로 DB를 이용하는 사용자계정을 등록하고 이용해보기.
--사용자 계정은 SYSTEM/SYS AS SYSDBA 계정이 등록한다.
--DB를 이용하려면 반드시 계정이 있어야한다.
--CREATE USER 계정명 IDENTIFIED BY 비밀번호 -> 계정생성 쿼리문. 비번만 대소문자 구분함.
CREATE USER KH IDENTIFIED BY KH;
CREATE USER SAMPLE IDENTIFIED BY USER;
SELECT * FROM DBA_USERS;
--GRANT 권한||롤 TO 계정명;  -> 특정 권한 부여하기
--CONNECT[ROLE] : 계정이 DB에 접속할 수 있는 권한 부여
GRANT CONNECT TO KH; -- 접속할 수 있는 권한 부여

--접속한 KH계정으로 조회해보기
--데이터를 확보활 공간 확보
SELECT * FROM TAB;
CREATE TABLE TEST1(
    NAME VARCHAR2(20)
); 

-- DROP TABLE TEST1 : 'TEST1' 테이블 삭제

--테이블을 생성하려면 생성할 수 있는 권한이 있어야함.
--RESOURCE (ROLE)를 부여 : 테이블을 생성하고 이용할 수 있는 권한이 있는 ROLE;
GRANT RESOURCE TO KH;

CREATE USER TEST IDENTIFIED BY TEST;
GRANT CONNECT, RESOURCE TO TEST;
CREATE TABLE TEST2(
    NAME VARCHAR2(20)
);

--DATA DICTIONARY
SELECT * FROM DICT; --관리자, 사용자 계정이 이용한다.
SELECT *
FROM EMPLOYEE; -- SELECT * FROM 테이블명 -> 테이블의 모든 데이터 조회
SELECT * FROM DEPARTMENT;

--기본 SELECT문 활용
--SELECT 컬럼명, 컬럼명 ....... 추가가능 
--FROM 테이블

SELECT EMP_ID, EMP_NAME, EMP_NO
FROM EMPLOYEE;

----------------------- 2021-02-26
 
 --RESULT SET에서 ROW 필터링 가져오려면 WHERE
SELECT *
FROM EMPLOYEE
WHERE SALARY<=3500000;

--DB에선 대부분 SELECT 문 안에서 이루어진다 -> 함수실행, 산술연산 등
--컬럼명이 들어가는 곳에서 산술연산 가능.
SELECT 10+20
FROM DUAL; --ORACLE이 제공하는 테스트용 테이블

SELECT SALARY, BONUS, SALARY+SALARY*BONUS
FROM EMPLOYEE;

--EMPLOYEE 테이블에서 각 사원의 연봉 조회
--컬럼명 AS 변경할컬럼명 (AS 생략하고 띄워쓰기로가능) "변경할컬럼명" -> ""안에 넣으면 띄워쓰기나 특수기호 사용 가능
SELECT EMP_NAME 사원명, SALARY*12 연봉, (SALARY+SALARY*BONUS)*12 AS 성과금포함연봉
FROM EMPLOYEE;
--없는 컬럼명은 추가가 된다
SELECT EMP_NAME, '님', 100
FROM EMPLOYEE;

SELECT DISTINCT DEPT_CODE --컬럼 중복값을 제거하고 출력
FROM EMPLOYEE;

SELECT DISTINCT DEPT_CODE, JOB_CODE -- 여러 컬럼을 적으면 해당 컬럼들끼리 ROW에서 겹치는 거만 삭제
FROM EMPLOYEE;

SELECT EMP_NAME||'님', SALARY||'원' --컬럼을 연결
FROM EMPLOYEE;

--EMPLOYEE 테이블에서 사원명 송종기의 전체 컬럼 조회
SELECT *
FROM EMPLOYEE
WHERE EMP_NAME='송종기';
--코드가 D5인 사원 조회
SELECT*
FROM EMPLOYEE
WHERE DEPT_CODE='D5';
--급여가 2백만원 이상인 사원 조회
SELECT *
FROM EMPLOYEE
WHERE SALARY>2000000;

--코드가 D5 혹은 D6인 사원의 사원명,급여,코드 조회
SELECT EMP_NAME, SALARY, DEPT_CODE
FROM EMPLOYEE
WHERE DEPT_CODE='D5' OR DEPT_CODE='D6';

--부서코드가 D5가 아닌 사원을 조회
SELECT *
FROM EMPLOYEE
WHERE NOT DEPT_CODE='D5';

--EMPLOYEE 테이블에서 급여 300~500만의 사원의 이름, 급여, 부서코드 조회
SELECT EMP_NAME, SALARY, DEPT_CODE
FROM EMPLOYEE
WHERE SALARY>3000000 AND SALARY<5000000;
--WHERE 컬럼 BETWEEN 값 AND 값 사용
SELECT EMP_NAME, DEPT_CODE, SALARY
FROM EMPLOYEE
WHERE SALARY BETWEEN 3000000 AND 5000000;

--고용일이 00/01/01 이전에 입사한 사원의 이름, 부서, 고용일 조회
SELECT EMP_NAME, DEPT_CODE, HIRE_DATE
FROM EMPLOYEE
WHERE HIRE_DATE<'00/01/01';

--고용일이 09/01/01~00/01/01 사이에 입사한 사원의 이름, 부서, 고용일 조회
SELECT EMP_NAME, DEPT_CODE, HIRE_DATE
FROM EMPLOYEE
WHERE HIRE_DATE BETWEEN '90/01/01' AND '00/01/01';


--LIKE : 특정 패턴의 문자값 조회
-- 와일드카드를 사용해서 조회 %, _
-- % : 0개 이상의 임의의 문자 표시
-- _ : 1개의 임의의 문자 표시

-- 1) 앞자리가 ze로 시작 : ze% (앞에는 ze로 시작하는걸 모조리 가져와라)
-- 2) 뒷자리가 com으로 끝남 : %com (com으로 끝나는걸 모조리 가져와라)
-- 3) 문장중에 a와 n을 포함 : %a%n% (어느 위치에 있는지는 모르지만 문장중에 a 와 n을 포함하는걸 모조리 가져와라)

--전씨 성을 가진 사언의 이름, 코드, 급여 조회
SELECT EMP_NAME, DEPT_CODE, SALARY
FROM EMPLOYEE
WHERE EMP_NAME LIKE '전_%';

--이름에 이 가 포함된 사원 조회
SELECT EMP_NAME, DEPT_CODE, SALARY
FROM EMPLOYEE
WHERE EMP_NAME LIKE '%이%';

--특수기호를 조건으로 쓰려면 ESCAPE 사용
SELECT*
FROM EMPLOYEE
WHERE EMAIL LIKE '___A_%' ESCAPE 'A';

--이 씨가 아닌 사원 조회
SELECT *
FROM EMPLOYEE
WHERE NOT EMP_NAME LIKE '이%';

--NULL 은 연산처리가 안된다. 
--IS NULL : NULL 값인 것 찾음

--보너스 못받는 사람 조회......
SELECT *
FROM EMPLOYEE
WHERE BONUS IS NULL;

--부서 미지정자 조회
SELECT *
FROM EMPLOYEE
WHERE DEPT_CODE IS NULL;

--IN/ NOT IN : 포함됐는지 안됐는지
SELECT *
FROM EMPLOYEE
WHERE (JOB_CODE='J7' OR JOB_CODE='J2') AND SALARY>2000000;

------------------ 2021-03-02

--ORDER BY : 데이터 순서 정렬
-- ASC : 오름차순, DESC : 내림차순
--ORDER BY 구문은 항상 맨 마지막에 작성
SELECT *
FROM EMPLOYEE
-- ORDER BY SALARY DESC; --내림차순
ORDER BY DEPT_CODE DESC NULLS LAST; -- NULLS LAST, NULLS FIRST 추가 가능
-- ORDER BY 3 DESC -- 3번째 COLUMN 선택, 별칭도 사용가능

--LENGTH(문자열||컬럼명) : 문자열 길이 반환
SELECT LENGTH(EMAIL)
FROM EMPLOYEE;
-- EMAIL 길이가 16이상인 사원의 전체 컬럼 조회
SELECT *
FROM EMPLOYEE
WHERE LENGTH(EMAIL)>=16;
-- LENGTHB(문자열||컬럼명) : 문자열 BYTE 크기

-- INSTR(대상 문자열||컬럼, 찾을 문자[, 시작위치, 횟수]) : 지정한 위치부터 지정한 횟수번째에 나타난 문자열 인덱스 반환
SELECT INSTR('KH정보교육원KH', 'KH',1,1) FROM DUAL; -- 1, 한번 찾으면 끝 // 지정위치가 음수면 뒤에서 부터 찾는다는 뜻
--EMAIL에서 @위치, 두번째 . 의 위치 찾기
SELECT INSTR(EMAIL,'@'), INSTR(EMAIL,'.',1,2)
FROM EMPLOYEE;

-- LPAD(왼) / RPAD(오른) : 특정 길이의 여백이 생기면 그 공간을 대체문자로 채움.
--LPAD(대상문자열, 지정길이[,대체문자])
SELECT '안녕', LPAD('안녕', 10) FROM DUAL; -- 대체문자 지정없으면 띄어쓰기로 대체

-- LTRIM/RTRIM(대상문자||컬럼[,문자) : 공백이나 특정 기호 제거 // TRIM 은 양쪽 제거
SELECT LTRIM('              무야호')
FROM DUAL;

-- SUBSTR('문자열', 시작인덱스[,길이]) : 지정한 위치를 제외한 문자열을 잘라내는 기능
SELECT SUBSTR('HELLO FUNCTION', 6)
FROM DUAL;
-- 이름에서 중복없이 성만 출력
SELECT DISTINCT(SUBSTR(EMP_NAME,1,1))
FROM EMPLOYEE;

--LOWER/UPPER/INICAP : 소문자로,대문자로, 띄어쓰기 다음을 대문자로 출력

--REPLACE(대상컬럼, 대상 문자열[, 대체문자열])
SELECT REPLACE(EMAIL, '@', '!!!!!!')
FROM EMPLOYEE;
--REVERSE : 문자열 거꾸로
--SELECT REVERSE('MUYAHO~ HE IS GOING CRAZY')
--FROM DUAL; --YZARC GNIOG SI EH ~OHAYUM

--TRANSLATE(대상문자열,치환대상,치환문자열)
SELECT TRANSLATE('무~야~호~','무야호','신난다')
FROM DUAL;

SELECT * FROM EMPLOYEE;
--EMPLOEE테이블에서 사원번호, 사원명, 주민번호, 연봉조회
-- 주민번호는 생년월일 제외한 나머지는 * 로 표시
SELECT EMP_NAME AS ENAME, SUBSTR(EMP_NO, 1, 8)||'*******' AS ENO
FROM EMPLOYEE;

--MOD(A, B) // A와B의 나머지 반환
SELECT MOD(10,3) FROM DUAL; -- 1

--ROUND(실수, 소수점 자리 수) : 실수의 소수점 자리수까지 남기고 그 뒤는 반올림 // 음수 가능
SELECT ROUND(1.12345, 2)
FROM DUAL; -- 1.12

--FLOOR : 소수점 삭제
SELECT FLOOR(1.2345) FROM DUAL; -- 소수점자리 삭제

--TRUC : 지정 위치 뒤 소수점 자리 버림
SELECT TRUNC(1.234, 2) FROM DUAL;

-- SYSDATE : 현재날짜 반환
SELECT SYSDATE FROM DUAL; -- +, - 로 하루더하고빼기 가능

--ADD_MONTHS : 개월수 증가
SELECT ADD_MONTHS(HIRE_DATE, 3) -- 3개월 증가
FROM EMPLOYEE;

--MONTHS_BETWEEN : 두 날짜의 개월 수 차이 반환
--EMPLOYEE 테이블에서 사원의 근무개월수를 구하시오
SELECT EMP_NAME, DEPT_CODE, SALARY, FLOOR(MONTHS_BETWEEN(SYSDATE, HIRE_DATE)) AS 근무개월수
FROM EMPLOYEE;

-- NEXT_DAY : 지정 요일이 가장 가까운 날짜 반환
-- LAST_DAY : 그 달의 마지막 날 출력
-- EXTRACT : 년월일시분초 를 따로 숫자형으로 반환
SELECT EXTRACT(YEAR FROM SYSDATE)
FROM DUAL;
-- 시분초  
SELECT EXTRACT(HOUR FROM CAST(SYSDATE AS TIMESTAMP)) FROM DUAL;
-- 사원명, 입사날(요일) 출력
SELECT EMP_NAME, TO_CHAR(HIRE_DATE, 'YYYY/MM/DD (DY)')
FROM EMPLOYEE;

SELECT SYSDATE AS "입대", ADD_MONTHS(SYSDATE, 18) AS "전역"
        ,TO_CHAR((ADD_MONTHS(SYSDATE,18)-SYSDATE)*3,'999,999,999') AS 짬밥먹은횟수
FROM DUAL;

--NVL : NULL 값을 다른 값으로 바꿀 때 사용하며, 모든 데이터 타입에 적용이 가능하다.

-- NVL2(expr, expr1, expr2) : expr의 값이 NULL이 아닐 경우에는 expr1의 값을 반환 , NULL일 경우에는 expr2의 값을 반환 한다.

-- DECODE(기준값, 조건1, 결과1, 조건2, 결과2,,,,,,결과DEFAULT) // 자바 SWITCH문과 비슷
SELECT EMP_NAME, EMP_NO, DECODE(SUBSTR(EMP_NO,8,1),'1','남자','여자') -- 주민번호로 남여 구별해서 출력
FROM EMPLOYEE;

------------------------------------------- 2021-03-03

-- CASE
--      WHEN 조건 THEN 실행구문
--      WHEN 조건 THEN 실행구문
--      ELSE
-- END;
SELECT EMP_NAME, EMP_NO,
        CASE   
            WHEN SUBSTR(EMP_NO,8,1)='1' THEN '남자'
            WHEN SUBSTR(EMP_NO,8,1)='2' THEN '여자'
        END AS 성별
FROM EMPLOYEE;

SELECT EMP_NAME, EMP_NO,
CASE SUBSTR(EMP_NO,8,1)
WHEN '1' THEN '남자'
ELSE '여자'
END AS 성별
FROM EMPLOYEE;

SELECT EMP_ID AS 사원번호, 
    EMP_NAME AS 사원명, 
    CONCAT (SUBSTR(EMP_NO,1,8), '*******') AS 주민번호, 
    CASE SUBSTR(EMP_NO, 8, 1)
        WHEN '1' THEN '남자' 
        ELSE '여자' 
        END AS 성별,
    EXTRACT (YEAR FROM SYSDATE) - EXTRACT (YEAR FROM TO_DATE(SUBSTR(EMP_NO,1, 2), 'RR'))+1 AS 현재나이
FROM EMPLOYEE;

insert into KH.EMPLOYEE (EMP_ID,EMP_NAME,EMP_NO,EMAIL,PHONE,DEPT_CODE,JOB_CODE,SAL_LEVEL,SALARY,BONUS,MANAGER_ID,HIRE_DATE,ENT_DATE,ENT_YN) 
values ('250','고두밋','470808-2123341','go_dm@kh.or.kr',null,'D2','J2','S5',4480000,null,null,to_date('94/01/20','RR/MM/DD'),null,'N');

-- 그룹함수..... 결과가 한 개의 ROW로 출력
SELECT SUM(SALARY)
FROM EMPLOYEE;
-- 여사원들의 총급여
SELECT SUM(SALARY)
FROM EMPLOYEE
WHERE SUBSTR(EMP_NO,8,1)='2';

--AVG : 컬럼 평균을 구한다
SELECT TO_CHAR(FLOOR(AVG(SALARY)),'L999,999,999') AS 평균급여
FROM EMPLOYEE;

-- COUNT(*||컬럼명) : 그룹의 ROW수를 구한다.
SELECT COUNT(*)
FROM EMPLOYEE;
-- 급여 300만원 이상인 사람 수
SELECT COUNT(*)
FROM EMPLOYEE
WHERE SALARY>3000000;

-- 그룹함수는 같이 출력 가능
SELECT COUNT(*), SUM(SALARY)
FROM EMPLOYEE;

-- MAX / MIN : 해당 칼럼에서 가장 큰 행을 반환 /  그 반대
SELECT MAX(SALARY), MIN(SALARY)
FROM EMPLOYEE;

-- GROUP BY : 특정 컬럼을 기준으로 그룹을 묶어줌
SELECT DEPT_CODE, SUM(SALARY)
FROM EMPLOYEE
GROUP BY DEPT_CODE;
--부서별 사원 수 조회
SELECT DEPT_CODE, COUNT(*)
FROM EMPLOYEE
GROUP BY DEPT_CODE;

SELECT JOB_CODE, SUM(SALARY), FLOOR(AVG(SALARY)), COUNT(*) AS 인원수
FROM EMPLOYEE
GROUP BY JOB_CODE
ORDER BY AVG(SALARY) DESC;

--직급 J1를 제외한 직급별 사원수, 평균급여
SELECT JOB_CODE, COUNT(*), FLOOR(AVG(SALARY))
FROM EMPLOYEE
WHERE JOB_CODE<>'J1'
GROUP BY JOB_CODE;

-- J1제외하고 입사년도별 인원수, 입사년 기준으로 오름차순
SELECT EXTRACT(YEAR FROM HIRE_DATE), COUNT(*)
FROM EMPLOYEE
WHERE JOB_CODE != 'J1'
GROUP BY EXTRACT(YEAR FROM HIRE_DATE)
ORDER BY 1 ASC;

--주민번호8번째 자리로 성별구분하고 인원 조회
SELECT DECODE(SUBSTR(EMP_NO, 8, 1),'1', '남', '2', '여') AS 성별, COUNT(*)
FROM EMPLOYEE
GROUP BY DECODE(SUBSTR(EMP_NO, 8, 1),'1', '남', '2', '여');

-- GROUB BY 에 다수의 컬럼.. 해당 컬럼들을 다 만족시키는 로우를 반환
SELECT DEPT_CODE, JOB_CODE, COUNT(*)
FROM EMPLOYEE
GROUP BY DEPT_CODE, JOB_CODE; -- 예를들어, D1 이면서 J1 인 사람들을 그룹화

-- 부서별로 평균급여 3백만 이상인 것들의 부서코드와 급여평균 조회
SELECT DEPT_CODE, FLOOR(AVG(SALARY)) AS 평균급여
FROM EMPLOYEE
-- WHERE AVG(SALARY)>=3000000 // SELECT- WHERE - GROUPBY - 평균급여 구하기 순으로 실행되기 때문에 안됨.
GROUP BY DEPT_CODE
HAVING AVG(SALARY)>=3000000; -- 그룹함수에서 필터링 할 때 사용.. WHERE는 사용안한다.

-- 부서인원이 3명 이상인 부서의 코드와 인원수 조회.. 내림차순으로
SELECT DEPT_CODE, COUNT(*)
FROM EMPLOYEE
GROUP BY DEPT_CODE
HAVING COUNT(*)>=3
ORDER BY 2 DESC; -- SELECT 2번째 컬럼 내림차순

------ <실습문제>
-- 이름, 메일, 메일길이 출력
SELECT EMP_NAME, EMAIL, LENGTH(EMAIL)
FROM EMPLOYEE;

--사원명, 생년, 보너스(NULL은 0으로) 출력
SELECT EMP_NAME AS 사원명, EXTRACT(YEAR FROM TO_DATE(SUBSTR(EMP_NO,1,2),'RR')) AS 년생, NVL(BONUS, 0)
FROM EMPLOYEE;

-- '010' 번호를 쓰지않는 사람의 수 출력
SELECT PHONE, COUNT(*)
FROM EMPLOYEE
GROUP BY PHONE
HAVING PHONE NOT LIKE '010%';

-- 직원명과 입사년월 출력
SELECT EMP_NAME AS 직원명, TO_CHAR(HIRE_DATE, '""YYYY"년"MM"월"DD"일"') AS 입사년월
FROM EMPLOYEE
ORDER BY 2 DESC;

-- 직원명과 주민번호(뒷번호 별표) 조회
SELECT EMP_NAME, SUBSTR(EMP_NO, 1, 7)||'*******'
FROM EMPLOYEE;

-- 직원명, 직급코드, 연봉(원화, 천의 자리 표기)
SELECT EMP_NAME, JOB_CODE, TO_CHAR(FLOOR(SALARY),'L999,999,999') AS 급여
FROM EMPLOYEE;

-- 부서코드 D5, D9인 직원 중 2004년 입사자 조회
SELECT EMP_ID, EMP_NAME, DEPT_CODE, HIRE_DATE
FROM EMPLOYEE
WHERE (DEPT_CODE='D5' OR DEPT_CODE='D9') AND EXTRACT(YEAR FROM HIRE_DATE)=2004;

-- 직원명, 입사일, 오늘까지 근무일수 조회
SELECT EMP_NAME, HIRE_DATE, FLOOR(SYSDATE - HIRE_DATE) AS 근무일수
FROM EMPLOYEE;

-- 부서코드, 이름을 나타내되, 부서코드 순 오름차순에 중복시 이름 오름차순
SELECT DEPT_CODE, EMP_NAME
FROM EMPLOYEE
ORDER BY 1,2;

------------------------ 2021-03-05

--ROLLUP, CUBE : 그룹함수를 사용하면 각 그룹별 합계구하고, 총계도 같이 출력됨(롤업은 마지막, 큐브는 처음)
SELECT NVL(DEPT_CODE,'총계'), SUM(SALARY)
FROM EMPLOYEE
WHERE DEPT_CODE IS NOT NULL
GROUP BY ROLLUP(DEPT_CODE);

-- 직책 별 인원 수와 총 인원 수를 구하시오
SELECT NVL(JOB_CODE, '총계'), COUNT(*)
FROM EMPLOYEE
WHERE JOB_CODE IS NOT NULL
GROUP BY ROLLUP (JOB_CODE);

-- 직책 별 인원 수와 총 인원 수를 구하시오(4명 이상인 부서만)
SELECT NVL(JOB_CODE, '총계'), COUNT(*)
FROM EMPLOYEE
GROUP BY ROLLUP (JOB_CODE)
HAVING COUNT(*)>=4;

-- ROLLUP, CUBE도 1개 이상의 컬럼을 설정
SELECT DEPT_CODE, JOB_CODE, SUM(SALARY)
FROM EMPLOYEE
WHERE DEPT_CODE IS NOT NULL
GROUP BY ROLLUP (DEPT_CODE, JOB_CODE);

-- GROUPING() : 집계된것이 ROLLUP, CUBE 로 된 것인지 확인하는 함수
-- 롤업큐브로 집계된거면 1 반환, 아니면 0

SELECT DEPT_CODE, COUNT(*), GROUPING(DEPT_CODE)
FROM EMPLOYEE
WHERE DEPT_CODE IS NOT NULL
GROUP BY ROLLUP (DEPT_CODE);

-- CUBE 2개 컬럼에서 GROUPING() 사용
SELECT DEPT_CODE, JOB_CODE, COUNT(*),
    CASE
        WHEN GROUPING(DEPT_CODE)=0 AND GROUPING(JOB_CODE)=1 THEN '부서별 합계'
        WHEN GROUPING(DEPT_CODE)=1 AND GROUPING(JOB_CODE)=0 THEN '직책별 합계'
        WHEN GROUPING(DEPT_CODE)=1 AND GROUPING(JOB_CODE)=1 THEN '총합계'
        ELSE '그룹별합계'
    END AS 구분
FROM EMPLOYEE
WHERE DEPT_CODE IS NOT NULL
GROUP BY CUBE(DEPT_CODE, JOB_CODE)
ORDER BY 1;

-- UNION : 2개 이상의 SELECT문의 합집합 (컬럼 수, 종류가 맞아야 한다).. 교집합은 INTERSECT
SELECT EMP_ID, DEPT_CODE, SALARY
FROM EMPLOYEE
WHERE DEPT_CODE='D5'
UNION
SELECT EMP_ID, DEPT_CODE, SALARY
FROM EMPLOYEE
WHERE SALARY>=3000000;

-- MINUS : 차집합.... 1번째 셀렉트문 - 1,2의 교집합
SELECT EMP_ID, EMP_NAME, DEPT_CODE, SALARY
FROM EMPLOYEE
WHERE DEPT_CODE='D5'
MINUS
SELECT EMP_ID, EMP_NAME, DEPT_CODE, SALARY
FROM EMPLOYEE
WHERE SALARY>=3000000;

-- 개인별 급여, 부서별 합계, 부서별 평균
SELECT '개인' AS DIV, NVL(DEPT_CODE,'인턴'), SALARY
FROM EMPLOYEE
UNION
SELECT '부서', NVL(DEPT_CODE,'인턴'), SUM(SALARY)
FROM EMPLOYEE
UNION
SELECT '부서평균', NVL(DEPT_CODE, '인턴'), FLOOR(AVG(SALARY))
FROM EMPLOYEE
GROUP BY DEPT_CODE;

-- GROUPING SETS() : GROUP BY 절에 여러개의 그룹 조건을 기술할 수 있다.

-- JOIN
--송중기 부서명 출력하기
--ORACLE 구문
SELECT EMP_NAME, DEPT_TITLE
FROM EMPLOYEE, DEPARTMENT
WHERE DEPT_CODE=DEPT_ID AND EMP_NAME='송종기';
--ANSI 구문
SELECT EMP_NAME, DEPT_TITLE
FROM EMPLOYEE JOIN DEPARTMENT ON DEPT_CODE=DEPT_ID
WHERE EMP_NAME='송종기';
-- 지역명, 국가명 출력
SELECT LOCAL_NAME, NATIONAL_NAME
FROM LOCATION JOIN NATIONAL ON LOCATION.NATIONAL_CODE=NATIONAL.NATIONAL_CODE;
-- 부서명과 지역명 출력
SELECT DEPT_TITLE, LOCAL_NAME
FROM DEPARTMENT JOIN LOCATION ON LOCATION_ID=LOCAL_CODE;
-- INNER JOIN : 2개 이상 테이블 조인할 때 일치하는 값이 없는 행은 조인에서 제외됨(JOIN은 이게 디폴트)
-- OUTER JOIN : 일치하지 않는 값도 포함이 된다.

--  CROSS JOIN : 모든 ROW 다 매칭시켜서 테이블 구성
SELECT EMP_ID, DEPT_CODE, EMP_NAME, DEPT_TITLE
FROM EMPLOYEE CROSS JOIN DEPARTMENT
ORDER BY 1;

-- SELF JOIN : 서로 같
SELECT EMP_ID, MANAGER_ID
FROM EMPLOYEE;

-- 매니저가 있는 사원의 이름 및 매니저 이름 조회
SELECT E.EMP_NAME AS 사원명, M.EMP_NAME AS 매니저명
FROM EMPLOYEE E JOIN EMPLOYEE M ON E.MANAGER_ID=M.EMP_ID;

-- 매니저가 있는 사원은 매니저의 EMP_ID, 이름 출력
-- ㄴ 없으면 EMP_ID 000, 이름 없음 출력
SELECT E.EMP_NAME, NVL(M.EMP_ID,'000'), NVL(M.EMP_NAME,'없음')
FROM EMPLOYEE E
LEFT JOIN EMPLOYEE M ON E.MANAGER_ID=M.EMP_ID;

-- 다중 JOIN : 2개 이상의 테이블을 조인하는 것

-- 사원명, 부서명, 근무하고 있는 지역명 조회
SELECT EMP_NAME, DEPT_TITLE, LOCAL_NAME
FROM EMPLOYEE
JOIN DEPARTMENT ON (DEPT_CODE=DEPT_ID)
JOIN LOCATION ON (LOCATION_ID=LOCAL_CODE);

----------------------------2021-03-08

-- 직급이 대리, ASIA 지역에 근무하는 직원의
-- 사번, 이름, 직급명, 부서명, 근무지역명, 급여(원화표시)
SELECT EMP_ID, EMP_NAME, JOB_NAME, DEPT_TITLE, LOCAL_NAME, TO_CHAR(FLOOR(SALARY),'L999,999,999') AS 급여
FROM EMPLOYEE
JOIN JOB ON (EMPLOYEE.JOB_CODE=JOB.JOB_CODE)
JOIN DEPARTMENT ON (DEPT_ID=DEPT_CODE)
JOIN LOCATION ON (LOCATION_ID=LOCAL_CODE)
WHERE JOB_NAME='대리' AND LOCAL_NAME LIKE 'ASIA%';

-- ㄴ 변수???? 사용
SELECT EMP_ID, EMP_NAME, JOB_NAME, DEPT_TITLE, LOCAL_NAME, TO_CHAR(FLOOR(SALARY),'L999,999,999') AS 급여
FROM EMPLOYEE E
JOIN JOB J ON (E.JOB_CODE=J.JOB_CODE)
JOIN DEPARTMENT D ON (DEPT_ID=DEPT_CODE)
JOIN LOCATION L ON (LOCATION_ID=LOCAL_CODE)
WHERE JOB_NAME='대리' AND LOCAL_NAME LIKE 'ASIA%';

-- NON EQUAL JOIN : 동등한 컬럼을 가지고 비교를 하는게 아니라 범위컬럼을 비교
SELECT EMP_NAME, SALARY, SAL_GRADE.SAL_LEVEL
FROM EMPLOYEE E
    JOIN SAL_GRADE ON (E.SALARY BETWEEN SAL_GRADE.MIN_SAL AND SAL_GRADE.MAX_SAL);

-- 전지연의 매니저 이름 조회 (단일행 서브쿼리 : 서브쿼리 RESULTSET이 1개 ROW 1개 인 것)
SELECT E.EMP_ID, E.EMP_NAME, E.MANAGER_ID, M.EMP_NAME AS 매니저명
FROM EMPLOYEE E
    JOIN EMPLOYEE M ON E.MANAGER_ID=M.EMP_ID
WHERE E.EMP_NAME='전지연';

-- 위를 서브쿼리 이용
SELECT EMP_NAME
FROM EMPLOYEE
WHERE EMP_ID=(SELECT MANAGER_ID FROM EMPLOYEE WHERE EMP_NAME='전지연');

-- 전체사원의 평균 급여보다 많이 받는 사원의 이름, 부서코드, 월급 조회
SELECT EMP_NAME, DEPT_CODE, SALARY
FROM EMPLOYEE
WHERE SALARY>(SELECT AVG(SALARY) FROM EMPLOYEE);

-- 전 사원 중 최소급여를 받는 사원의 이름, 부서코드, 직책코드, 월급 조회
SELECT MIN(SALARY) FROM EMPLOYEE;
SELECT EMP_NAME, DEPT_CODE, JOB_CODE, SALARY
FROM EMPLOYEE
WHERE SALARY = (SELECT MIN(SALARY) FROM EMPLOYEE);

-- 최대급여를 받는 사원과 윤은해랑 같은 급여 받는 사원 조회
SELECT EMP_NAME, DEPT_CODE, JOB_CODE, SALARY
FROM EMPLOYEE
WHERE SALARY = (SELECT MAX(SALARY) FROM EMPLOYEE)
    OR SALARY=(SELECT SALARY FROM EMPLOYEE WHERE EMP_NAME='윤은해');

-- 다중행 서브쿼리 : 서브쿼리 결과 (RESULTSET) 컬럼 1개, ROW 다수
SELECT DEPT_CODE FROM EMPLOYEE WHERE EMP_NAME IN ('송종기','윤은해');
SELECT EMP_NAME, DEPT_CODE
FROM EMPLOYEE
--WHERE DEPT_CODE = (SELECT DEPT_CODE FROM EMPLOYEE WHERE EMP_NAME IN ('송종기', '윤은해')); = 사용 안됨
WHERE DEPT_CODE IN (SELECT DEPT_CODE FROM EMPLOYEE WHERE EMP_NAME IN ('송종기', '윤은해'));
-- ㄴ WHERE DEPT_CODE IN('D9', 'D5');

-- 대표, 부사장을 제외한 사원의 사원명, 부서명, 직책명 조회
SELECT EMP_NAME, DEPT_TITLE, JOB_NAME
FROM EMPLOYEE
    JOIN JOB ON (JOB.JOB_CODE=EMPLOYEE.JOB_CODE)
    JOIN DEPARTMENT ON (DEPT_ID=DEPT_CODE)
WHERE JOB_NAME NOT IN (SELECT JOB_NAME FROM DEPARTMENT WHERE JOB_NAME IN('대표','부사장'));

-- 직급이 대표, 부사장이 아닌 ASIA1 에서 근무하는 사원 조회
SELECT EMP_NAME
FROM EMPLOYEE
WHERE JOB_CODE NOT IN (SELECT JOB_CODE
                            FROM JOB
                        WHERE JOB_NAME IN('부사장', '대표'))
                            AND DEPT_CODE IN (SELECT DEPT_ID
                            FROM DEPARTMENT
                            JOIN LOCATION ON LOCATION_ID=LOCAL_CODE WHERE LOCAL_NAME='ASIA1');

-- 다중행 서브쿼리를 동등비교 했을 땐, 결괏값을 OR로 묶어서 처리한다.

-- ANY / ALL 다중값에 대해 대소비교를 할 수 있는 예약어
-- ANY : RESULTSET 으로 나온값을 OR 연결해서 대소비교 한다.
-- X > ANY(다중행서브쿼리) : ANY에 있는 어떤 값보다 X가 크면 TRUE -> 최소값보다 크면 TRUE;

-- D5,D6부서에서 최저급여 받는 사원보다 많이받는 사원의 이름 월급 부서코드 조회
SELECT EMP_NAME, SALARY, DEPT_CODE
FROM EMPLOYEE
WHERE SALARY > ANY(SELECT SALARY FROM EMPLOYEE WHERE DEPT_CODE IN ('D6', 'D5'));

-- 직책이 J3, J5인 사원 최소급여 보다 많이 받는 사원 조회
SELECT *
FROM EMPLOYEE
WHERE SALARY > ANY(SELECT SALARY FROM EMPLOYEE WHERE JOB_CODE IN ('J3', 'J5'));

-- X < ANY (서브쿼리) : ANY에 있는 어떤 값보다 X가 작기만 하다 -> 최댓값보다 작으면 TRUE.

-- 부서 D2, D5 에서 최대급여인 사원보다 더 받는 사원 조회
SELECT *
FROM EMPLOYEE
WHERE SALARY > (SELECT MAX(SALARY) FROM EMPLOYEE WHERE DEPT_CODE = 'D2' OR DEPT_CODE = 'D5');

-- 다중행, 다중열 서브쿼리 : 행, 열 모두 다수

-- 부서별 최소급여 조회
SELECT DEPT_CODE, MIN(SALARY)
FROM EMPLOYEE
GROUP BY DEPT_CODE;
-- 부서별 최소급여받는 사원 조회
SELECT *
FROM EMPLOYEE
WHERE (DEPT_CODE, SALARY) IN (SELECT DEPT_CODE, MIN(SALARY) FROM EMPLOYEE GROUP BY DEPT_CODE);

-- 부서별 최대급여 사원 하고 최소급여 받는 사원 조회
-- 사원명, 부서명, 급여 출력.. NULL 도 출력
SELECT EMP_NAME, NVL(DEPT_TITLE,'인턴'), SALARY
FROM EMPLOYEE
    LEFT JOIN DEPARTMENT ON DEPT_CODE=DEPT_ID
WHERE (NVL(DEPT_CODE,1), SALARY)IN(SELECT NVL(DEPT_CODE,1), MAX(SALARY)
                                    FROM EMPLOYEE GROUP BY DEPT_CODE)
    OR (NVL(DEPT_CODE,'GOM'), SALARY)IN(SELECT NVL(DEPT_CODE,'GOM'), MIN(SALARY)
                                    FROM EMPLOYEE GROUP BY DEPT_CODE);

-- 상관서브쿼리(상호연관) : 메인뭐리의 값을 서브쿼리에 주고 서브쿼리를 수행한 다음 그 결과를 다시 메인쿼리로 반환
-- ㄴ 서브쿼리의 WHERE절에 메인쿼리의 값을 가져와 비교

-- EXISTS : 서브쿼리 결과가 있을 때 ROW 있으면 TRUE, ROW 0개면 FALSE

SELECT *
FROM EMPLOYEE
WHERE EXISTS (SELECT 1 FROM EMPLOYEE WHERE EMP_ID='200');

-- 상관서브쿼리로 DEPT_CODE 가 있는 사원 출력
-- IS NOT NULL 또는 JOIN 미사용
-- 이름, DEPT_CODE
SELECT EMP_NAME, DEPT_CODE
FROM EMPLOYEE E
WHERE EXISTS(SELECT EMP_NAME FROM EMPLOYEE WHERE DEPT_CODE=E.DEPT_CODE);
-- 웨어절 셀렉트 바로 뒤 EMP_NAME에는 아무 컬럼이나 넣어도 됨. 값이 있나 확인용이라..

-- 급여를 가장 많이받는 사원을 상관서브쿼리로 조회
-- 사워명, 급여
SELECT EMP_NAME, SALARY
FROM EMPLOYEE E
WHERE NOT EXISTS(SELECT '돈많다~' FROM EMPLOYEE WHERE SALARY>E.SALARY);

-- 직급이 J1,J2,J3가 아닌 사원 중에서 자신의 부서 평균급여보다 많이 받는 사원 조회
SELECT EMP_NAME, DEPT_CODE, SALARY
FROM EMPLOYEE E
WHERE JOB_CODE NOT IN ('J1','J2','J3')
                AND SALARY>(SELECT AVG(SALARY)FROM EMPLOYEE WHERE DEPT_CODE=E.DEPT_CODE);

------------------- 2021-03-09

-- 스칼라 서브쿼리 : 상관서브쿼리, RESULTSET이 무조건 단일행인 것
-- 컬럼 작성하는 곳에 사용가능. WHERE절에서 사용 가능
-- 모든 사원의 매니저 이름 조회
SELECT EMP_ID, EMP_NAME, MANAGER_ID,
       NVL((SELECT EMP_NAME FROM EMPLOYEE M WHERE E.MANAGER_ID=M.EMP_ID ), '없음') AS 매니저이름
FROM EMPLOYEE E;

-- 사원명, 부서코드, 부서별 평균임금 조회
SELECT EMP_NAME, DEPT_CODE,
       TO_CHAR(FLOOR((SELECT AVG(SALARY) FROM EMPLOYEE WHERE DEPT_CODE=E.DEPT_CODE)),'L999,999,999')
FROM EMPLOYEE E;

-- 자신의 부서의 평균급여보다 많이 받는 사원을 조회
SELECT EMP_NAME, DEPT_TITLE, SALARY
FROM EMPLOYEE E
JOIN DEPARTMENT ON (DEPT_CODE=DEPT_ID)
WHERE SALARY > (SELECT AVG(SALARY) FROM EMPLOYEE EE WHERE EE.DEPT_CODE=E.DEPT_CODE);

-- 인라인 뷰 : FROM절에 서브쿼리 사용한 것
-- 실제 물리적테이블에 있는 값이 아닌 가상의 테이블 값
-- INLINE VIEW : 1번만 사용할 수 이쓴 테이블로 쓰이는 서브 쿼리문
-- STORED VIEW : 테이블로 쓰이는 서브쿼리문을 저장하고 이름을 부여해서 재호출 가능 -> VIEW

-- 여사원의 사번, 사원명, 부서코드, 성별 조회
SELECT EMP_ID, EMP_NAME, DEPT_CODE, DECODE(SUBSTR(EMP_NO,8,1),'1','남',2,'여') AS 성별
FROM EMPLOYEE
WHERE DECODE(SUBSTR(EMP_NO,8,1),'1','남',2,'여')='여';

-- INLINE VIEW로 처리
SELECT *
FROM (SELECT EMP_ID, EMP_NAME, DEPT_CODE, DECODE(SUBSTR(EMP_NO,8,1),'1','남',2,'여') AS 성별
     FROM EMPLOYEE)
WHERE 성별='여';

-- TOP-N 분석 : 순위를 부여하는 것
-- 급여를 많이 받는 사원 1~3위 조회
SELECT EMP_NAME, SALARY
FROM EMPLOYEE
ORDER BY SALARY DESC; -- 이건 순위컷 불가

-- 순위컷
SELECT ROWNUM, EMP_NAME, SALARY
FROM EMPLOYEE
WHERE ROWNUM <= 3;


SELECT ROWNUM, E.*
FROM (
        SELECT *
        FROM EMPLOYEE
        ORDER BY SALARY DESC
        ) E
WHERE ROWNUM <=3;

DELETE FROM EMPLYOEE
WHERE EMP_NAME = 'GOM';

-- 급여 5~10위 조회
SELECT *
FROM (
    SELECT ROWNUM AS RNUM, E.*
    FROM (SELECT EMP_NAME, SALARY
        FROM EMPLOYEE
        ORDER BY SALARY DESC) E
    )
WHERE RNUM BETWEEN 5 AND 10;
-- ROWNUM으로 비교하면 1부터 시작함.
-- 위에건 게시판 구성할 때, PAGING 처리에 사용하는 SQL문이다.

-- D5부서 고연봉 3명 조회
SELECT *
FROM (
         SELECT ROWNUM AS RNUM, E.*
         FROM (
                  SELECT EMP_NAME, DEPT_CODE, DEPT_TITLE, SALARY, (SALARY + (SALARY * NVL(BONUS, 0))) * 12 AS 연봉
                  FROM EMPLOYEE
                           JOIN DEPARTMENT ON DEPT_CODE = DEPT_ID
                  WHERE DEPT_CODE='D5'
                  ORDER BY 4 DESC
              ) E
     )
WHERE RNUM BETWEEN 1 AND 3;

-- 함수 이용해서 순위 매기기
-- RANK() OVER : 각 ROW에 순서 부여
SELECT *
FROM (
      SELECT EMP_NAME, SALARY,
      RANK() OVER (ORDER BY SALARY DESC) AS 순위
FROM EMPLOYEE
    )
WHERE 순위 BETWEEN 1 AND 3;

SELECT SALARY, RANK() OVER (ORDER BY SALARY DESC) AS 순위
FROM EMPLOYEE
WHERE SALARY IS NOT NULL;

SELECT * FROM EMPLOYEE;

SELECT ROWNUM, E.*
FROM EMPLOYEE E;





-- DENSE_RANK() : 중복값이 있을 때 번호 뛰어넘지 않음
SELECT RANK() OVER (ORDER BY SALARY) AS 순위,
       EMP_NAME, SALARY,
       DENSE_RANK() OVER (ORDER BY SALARY) AS DENSE순위
FROM EMPLOYEE;

-- 계층형 쿼리 : 각 ROW별 연결할 수 있는 컬럼 필요
-- 댓글, 대댓글 사용할 때 이용하는 쿼리문이다.
SELECT EMP_ID, EMP_NAME, MANAGER_ID
FROM EMPLOYEE;

SELECT EMP_ID, EMP_NAME, MANAGER_ID
FROM EMPLOYEE
START WITH EMP_ID=200
CONNECT BY PRIOR EMP_ID=MANAGER_ID;

SELECT LEVEL ||''||LPAD('',(LEVEL-1)*5,'' )||EMP_NAME|| NVL2(MANAGER_ID,'('||MANAGER_ID||')','') AS 조직도
FROM EMPLOYEE
--START WITH EMP_ID=200
START WITH MANAGER_ID IS NULL
CONNECT BY PRIOR EMP_ID=MANAGER_ID;

-- ORACLE 의 데이터형
-- VARCHAR2 : 가변형 문자열 타입으로, 대입된 데이터만큼 공간 확보
-- CHAR : 고정형 문자열 타입으로 길이만큼 공간을 확보

CREATE TABLE TBL_STR(
    A CHAR(6),
    B VARCHAR2(6)
);

SELECT *
FROM TBL_STR;

INSERT  INTO TBL_STR VALUES ('ABC','AAA');

SELECT LENGTHB(A), LENGTHB(B) FROM TBL_STR;

-- NUMBER : 모든 숫자형
-- NUMBER([PRECISION, SCALE])
-- PRECISON : 표현할 수 있는 전체 자리수
-- SCALE : 소수점 이하 자리수
CREATE TABLE TBL_NUM(
    A NUMBER,
    B NUMBER(5),
    C NUMBER(5,1),
    D NUMBER(5,-2)
);
SELECT*FROM TBL_NUM;
INSERT INTO TBL_NUM VALUES(123.1123,213.1123,123.3144,213.1231);

CREATE TABLE TBL_DATE(
    BIRTHDAY DATE,
    DAY TIMESTAMP
);

INSERT INTO TBL_DATE VALUES (SYSDATE, SYSTIMESTAMP);
SELECT*FROM TBL_DATE;
INSERT INTO TBL_DATE VALUES ('1920/11/23', '1999/11/12');

-- 기본 테이블 생성
-- CREATE TABLE 테이블명 (컬럼명 자료형, 컬럼명 자료형.............);
CREATE TABLE MEMBER(
    MEMBER_ID VARCHAR2(20),
    MEMBER_PWD VARCHAR2(20),
    MEMBER_NAME VARCHAR2(20)
);

-- 테이블 컬럼에 COMMENTS 설정하기
-- COMMENT ON COLUMN 테이블.컬럼명 IS 코멘트내용
COMMENT ON COLUMN MEMBER.MEMBER_ID IS '회원아이디';
COMMENT ON COLUMN MEMBER.MEMBER_PWD IS '회원비번';

-- 코멘트 포함 테이블 조회
SELECT * FROM USER_COL_COMMENTS
    WHERE TABLE_NAME='MEMBER';

DROP TABLE TBL_STR; -- 테이블 삭제

SELECT*FROM MEMBER;

----------------- 2021-03-10
-- 제약 조건
-- NOT NULL : 지정한 열에 NULL을 허용하지 않음. NULL 제외한 데이터의 중복 허용. (C)
-- UNIQUE : 지정한 열이 유일한 값을 가져야 함(중복 비허용). 오라클에선 NULL은 중복에서 제외된다. (U)
-- PRIMARY KEY : 지정한 열이 유일한 값이면서 NULL 비허용. 테이블에 하나만 지정 가능. (P)
-- FOREIGN KEY : 다른 테이블의 열을 참조해서 존재하는 값만 입력 가능. 참조할 열에는 중복값이 없어야 함. (R)
-- CHECK : 설정한 조건식을 만족하는 데이터만 입력 가능. (C)

-- 테이블에 설정된 제약 조건 확인
SELECT *
FROM USER_CONSTRAINTS;
SELECT*FROM USER_CONS_COLUMNS;
-- 테이블에 대한 제약 조건을 검색할 땐 2개 테이블을 조인해서 사용
SELECT*
FROM USER_CONSTRAINTS
JOIN USER_CONS_COLUMNS USING(CONSTRAINT_NAME);

-- NOT NULL
SELECT * FROM MEMBER;
CREATE TABLE CONS_NN(
    USER_NO NUMBER,
    USER_NAME VARCHAR2(20),
    EROLL_DATE DATE
); -- 일반적인 테이블 생성
DROP TABLE CONS_NN;

CREATE TABLE CONS_NN(
    USER_NO NUMBER NOT NULL,
    USER_NAME VARCHAR2(20) NOT NULL,
    EROLL_DATE DATE
); -- NOT NULL 설정

INSERT INTO CONS_NN VALUES (NULL, NULL, NULL); -- 삽입 불가

-- UNIQUE
CREATE TABLE TBL_USER_UQ(
    USER_NO NUMBER,
    USER_ID VARCHAR2(20) UNIQUE ,
    USER_PWD VARCHAR2(20),
    USER_NAME VARCHAR2(20),
    EMAIL VARCHAR2(20) UNIQUE
);
--유니크 그룹화
CREATE TABLE TBL_USER_UQ(
    USER_NO NUMBER,
    USER_ID VARCHAR2(20) NOT NULL UNIQUE,
    USER_PWD VARCHAR2(20),
    USER_NAME VARCHAR2(20),
    EMAIL VARCHAR2(20),
    UNIQUE (USER_ID, EMAIL) -- 그룹화.. 윗 테이블의 유니크랑 다름.
);

DROP TABLE TBL_USER_UQ;
SELECT*FROM TBL_USER_UQ;
INSERT INTO TBL_USER_UQ VALUES (1, 'GOM', '1234', 'JANG', 'JANG@NAVER.COM'); -- 중복 삽입 불가

-- PRIMARY KEY : 중복값 없고 NULL도 없어야 함. 한 테이블당 한 PK만 가능.
CREATE TABLE TBL_USER_PK(
    USER_NO NUMBER PRIMARY KEY,
    USER_ID VARCHAR2(20) NOT NULL UNIQUE,
    USER_PWD VARCHAR2(20) NOT NULL
);

-- 상품, 날짜, 수량, 아이디, 주문번호
CREATE TABLE TBL_ORDER(
    PRODUCT_NO NUMBER,
    USER_ID VARCHAR2(20),
    ORDER_DATE DATE,
    COUNT NUMBER,
    ORDER_NO NUMBER,
    PRIMARY KEY (PRODUCT_NO, USER_ID, ORDER_DATE)
);
DROP TABLE TBL_ORDER;
INSERT INTO TBL_ORDER VALUES (2, 'ADMIN', '21/03/10',10,1);
SELECT*FROM TBL_ORDER;

-- 외래키 (FOREIGN KEY) : 다른 테이블의 열을 참조해서 존재하는 값만 입력 가능. 참조할 열에는 중복값이 없어야 함. (R)
-- 카테고리, 부서명 , 학과명
-- 부모자식 관계가 성립

-- 게시판
CREATE TABLE BOARD (
    BOARD_NO NUMBER,
    BOARD_TITLE VARCHAR2(20) NOT NULL,
    BOARD_CONTENT VARCHAR2(2000),
    BOARD_WRITE VARCHAR2(20) REFERENCES MEMBER(USER_ID), -- 밑 테이블 MEMBER가 글을 쓰는 것이니, FOREIGN 사용
    BOARD_DATE DATE
);
DROP TABLE BOARD;
DROP TABLE MEMBER;
CREATE TABLE MEMBER(
    USER_ID VARCHAR2(20) NOT NULL UNIQUE ,
    USER_PWD VARCHAR2(20)
);

INSERT INTO MEMBER VALUES ('USER01','USER01');
SELECT*FROM MEMBER;
INSERT INTO BOARD VALUES (1, '무야호', NULL,'USER01', SYSDATE);
SELECT*FROM BOARD;

CREATE TABLE SHOP_BUY(
    BUY_NO NUMBER PRIMARY KEY ,
    USER_ID VARCHAR2(20) NOT NULL,
    PRODUCT_NAME VARCHAR2(50),
    REG_DATE DATE,
    FOREIGN KEY (USER_ID) REFERENCES MEMBER2(USER_ID) ON DELETE SET NULL
);

SELECT * FROM SHOP_BUY;
INSERT INTO SHOP_BUY VALUES (1, 'USER01', 'AIR CONDITIONAL', SYSDATE);
INSERT INTO SHOP_BUY VALUES (3, 'USER02', 'AIR CONDITIONAL', SYSDATE); -- USER02는 MEMBER 테이블에 없으므로 ERROR

CREATE TABLE MEMBER2(
    USER_ID VARCHAR2(20) UNIQUE,
    USER_PWD VARCHAR2(20)
);

SELECT * FROM MEMBER2;
DROP TABLE SHOP_BUY;
DROP TABLE MEMBER2;

-- 참조된 값은 함부로 데이터를 수정하지 못하게 만듦
SELECT * FROM BOARD;
DELETE FROM MEMBER2 WHERE USER_ID='USER01'; -- 참조중인 테이블이 있어서 실행안됨
DELETE FROM BOARD WHERE BOARD_WRITE='USER01'; -- BOARD_WRITE에서 참조하고 있어서 이걸 실행하면 위 MEMBER에서 지울 수 있다

-- ㄴ 잠조관계 있을 땐, 못지우는게 DEFAULT지만 옵션 설정시 가능.
-- ON DELETE SET NULL / ON CASCADE

INSERT INTO MEMBER2 VALUES('USER01', 'USER01');
INSERT INTO SHOP_BUY VALUES(1, 'USER01', '아이스크림', SYSDATE);

-- CHECK : 내가 설정한 값만 저장가능
CREATE TABLE USER_CHECK(
    USER_NO NUMBER,
    USER_NAME VARCHAR2(20),
    GENDER VARCHAR2(10) CHECK(GENDER IN('남','여')),
    AGE NUMBER,
    CHECK(AGE BETWEEN 10 AND 30)
);
INSERT INTO USER_CHECK VALUES (1,'곰저씨','남',20); -- 가능
SELECT*FROM USER_CHECK;
DROP TABLE USER_CHECK;

CREATE TABLE CONS_NAME(
    USER_ID VARCHAR2(20) CONSTRAINT CONS_NAME_PK PRIMARY KEY,
    USER_NAME VARCHAR2(20),
    CONSTRAINT USER_NAME_UQ UNIQUE (USER_NAME)
);

SELECT * FROM USER_CONS_COLUMNS
WHERE TABLE_NAME = 'CONS_NAME';

------------------------ 20221-03-11 TEST

SELECT DEPT_TITLE AS 부서명, SUM(SALARY) AS 급여합
FROM EMPLOYEE
JOIN DEPARTMENT ON (DEPT_CODE=DEPT_ID)
GROUP BY DEPT_TITLE;

-- 직원명과 주민번호(뒷번호 별표) 조회
SELECT EMP_NAME AS 사원명, SUBSTR(EMP_NO, 1, 7)||'*******' AS 주민번호
FROM EMPLOYEE;

-- 부서별로 평균급여 3백만 이상인 것들의 부서코드와 급여평균 조회
SELECT DEPT_CODE, FLOOR(AVG(SALARY)) AS 평균급여
FROM EMPLOYEE
-- WHERE AVG(SALARY)>=3000000 // SELECT- WHERE - GROUPBY - 평균급여 구하기 순으로 실행되기 때문에 안됨.
GROUP BY DEPT_CODE
HAVING AVG(SALARY)>=3000000; -- 그룹함수에서 필터링 할 때 사용.. WHERE는 사용안한다.

SELECT DEPT_CODE, SUM(SALARY) AS 합계, FLOOR(AVG(SALARY)) AS 평균, COUNT(*) AS 인원수
FROM EMPLOYEE
GROUP BY DEPT_CODE
HAVING AVG(SALARY)>=2800000
ORDER BY DEPT_CODE ASC;

SELECT EMP_NAME, JOB_CODE, COUNT(*) AS 사원수
FROM EMPLOYEE
WHERE BONUS != 'NULL'
GROUP BY  JOB_CODE
ORDER BY JOB_CODE;

SELECT EMP_NAME, NVL(JOB_CODE, 0), COUNT(*) AS 사원수
FROM EMPLOYEE
GROUP BY  (JOB_CODE, EMP_NAME)
ORDER BY JOB_CODE;

----------- 2021-03-12

-- 서브쿼리 이용 테이블 만들기

-- 테이블 만들고 복사해오기
CREATE TABLE EMP_COPY
AS SELECT * FROM EMPLOYEE;

SELECT * FROM EMPLOYEE;
DROP TABLE EMP_COPY;

-- 복사시 데이터 없이 테이블만 생성하려면?
CREATE TABLE EMP_COPY
AS SELECT EMP_NAME, DEPT_CODE, JOB_CODE, SALARY
    FROM EMPLOYEE WHERE 1=2;
SELECT * FROM EMP_COPY;

-- DML (Data Manipulation Language.....INSERT, UPDATE, DELETE)
-- 1. 지정한 컬럼에만 데이터 추가해보기 (지정안된건 NULL)
INSERT INTO DEPARTMENT(DEPT_ID, LOCATION_ID) -- 지정되지 않은 컬럼에 NOT NULL 설정되어 있으면 오류
VALUES ('A1', 'L3');

-- 모든 컬럼에 값 넣기
INSERT INTO DEPARTMENT
VALUES ('A2', '오라클개발부', 'L4'); -- NULL을 넣는것도 가능

-- INSERT문에 서브쿼리 이용해보기
CREATE TABLE INSERT_TEST
AS SELECT EMP_ID, EMP_NAME, DEPT_TITLE
    FROM EMPLOYEE JOIN DEPARTMENT ON DEPT_CODE=DEPT_ID
    WHERE 1=2;

SELECT * FROM INSERT_TEST;

INSERT INTO INSERT_TEST
VALUES ('1', 'GOM', '개발팀');

-- 기존에 있는 데이터를 복사해서 넣어보기
INSERT INTO INSERT_TEST (SELECT EMP_ID, EMP_NAME, DEPT_TITLE
    FROM EMPLOYEE JOIN DEPARTMENT ON DEPT_CODE=DEPT_ID
    WHERE DEPT_CODE='D5'
);

-- INSERT ALL : 2개 이상의 테이블에 한 SELECT문의 결괏값을 넣는다.
CREATE TABLE EMP_HIRE_DATE
AS SELECT EMP_ID, EMP_NAME, HIRE_DATE
FROM EMPLOYEE WHERE 1=0;
CREATE TABLE EMP_MANAGE
AS SELECT EMP_ID, EMP_NAME, MANAGER_ID
FROM EMPLOYEE WHERE 1=0;

INSERT ALL
INTO EMP_HIRE_DATE VALUES(EMP_ID, EMP_NAME, HIRE_DATE)
INTO EMP_MANAGE VALUES(EMP_ID, EMP_NAME, MANAGER_ID)
SELECT EMP_ID, EMP_NAME, HIRE_DATE, MANAGER_ID
FROM EMPLOYEE;

SELECT*FROM EMP_HIRE_DATE;

-- INSERT ALL를 조건에 따라 분리해서 삽입해보기
CREATE TABLE EMP_OLD
AS SELECT EMP_ID, EMP_NAME, SALARY, HIRE_DATE
FROM EMPLOYEE
WHERE 1=0;

CREATE TABLE EMP_NEW
AS SELECT EMP_ID, EMP_NAME, SALARY, HIRE_DATE
FROM EMPLOYEE WHERE 1=0;

SELECT*FROM EMP_OLD;
SELECT*FROM EMP_NEW;

INSERT ALL
WHEN '00/01/01'>HIRE_DATE THEN INTO EMP_OLD VALUES(EMP_ID, EMP_NAME, SALARY, HIRE_DATE)
WHEN '00/01/01'<= HIRE_DATE THEN INTO EMP_NEW VALUES(EMP_ID, EMP_NAME, SALARY, HIRE_DATE)
SELECT EMP_ID, EMP_NAME, SALARY, HIRE_DATE
FROM EMPLOYEE;

-- UPDATE : 컬럼값을 수정.. 테이블 전체 행 갯수는 변화가 없다.
CREATE TABLE EMP_COPY
AS SELECT * FROM EMPLOYEE;
DROP TABLE EMP_COPY;
SELECT*FROM EMP_COPY;
-- 'A1'부서의 부서명을 '자바개발부'로 변경.. UPDATE에서 WHERE 빼먹지 말기! 전부 바뀌어버린다..
UPDATE DEPT_COPY SET DEPT_TITLE='자바개발부' WHERE DEPT_ID='A1';

-- UPDATE 문에서 서브쿼리 사용해보기
-- 급여가 200만원 미만인 사원의 보너스를 0.4로 변경하기
UPDATE EMP_COPY SET BONUS=0.4 WHERE SALARY<2000000;

-- 방명수의 월급을 심봉선과 같게 변경하기
UPDATE EMP_COPY SET SALARY=(SELECT SALARY FROM EMP_COPY WHERE EMP_NAME='심봉선')
WHERE EMP_NAME = '방명수';

-- 방명수의 월급과 보너스를 전지연의 월급과 보너스와 같게 변경하기
UPDATE EMP_COPY SET (SALARY, BONUS)=(SELECT SALARY, BONUS FROM EMP_COPY WHERE EMP_NAME='전지연')
WHERE EMP_NAME='방명수';

-- 임시환의 직급을 과장, 부서를 해외영업3부로 변경하는 쿼리 작성
UPDATE EMP_COPY SET (JOB_CODE, DEPT_CODE)=(SELECT JOB_CODE, DEPT_CODE
    FROM JOB CROSS JOIN DEPARTMENT
    WHERE JOB_NAME='과장' AND DEPT_TITLE='해외영업3부')
-- SET JOB_CODE=(SELECT JOB_CODE FROM JOB WHERE JOB_NAME ='과장'),
--                     DEPT_CODE=(SELECT DEPT_ID FROM DEPARTMENT WHERE DEPT_TITLE='해외영업3부')
WHERE EMP_NAME='임시환';

-- DELETE : 조건에 맞는 ROW를 삭제하는 명령어
-- DELETE FROM 테이블 [WHERE 조건식] // WHERE절 생략시 전체 삭제

-- 차태연 삭제하기
DELETE FROM EMP_COPY WHERE EMP_NAME='차태연';

-- BONUS 안받는 사원 삭제
DELETE FROM EMP_COPY WHERE BONUS IS NULL;

-- TRUNCATE : 테이블 전체 행 삭제.. DELETE보다 빠르고 ROLLBACK으로 복구 불가능

-- MERGE : 구조가 같은 2개의 테이블을 1개의 테이블로 합치는 기능
-- MERGE INTO 기준이 될 테이블
-- USING 합칠테이블 ON (동일여부 판단할 기준컬럼)
-- WHEN [NOT]MATCHED THEN DML구문
MERGE INTO TBL_MERGE01
USING TBL_MERGE02 ON (TBL_MERGE01.ID=TBL_MERGE02.ID)
WHEN MATCHED THEN UPDATE TBL_MERGE01.NAME=TBL_MERGE02.NAME;

-- DDL (Dtat Definition Language) : 객체를 CREATE, ALTER(수정), DROP

-- ALTER : 테이블에 정의된 내용을 수정할 때 사용..
-- ㄴ 컬럼 및 제약조건의 삭제/추가, 컬럼의 자료형 변경, DEFAULT값 변경, 테이블-컬럼-제약조건 이름을 바꿀 수 있다.

CREATE TABLE TBL_USER_ALTER(
    USER_NO NUMBER PRIMARY KEY,
    USER_ID VARCHAR2(20),
    USER_PWD VARCHAR2(20),
    USER_NAME VARCHAR2(20)
);

INSERT INTO TBL_USER_ALTER VALUES (1, 'ADMIN', '1234', '관리자');
INSERT INTO TBL_USER_ALTER VALUES (2, 'USER01', 'USER01', '유저일1');

-- 테이블에 데이터가 있는 상태에서 새 컬럼 추가
ALTER TABLE TBL_USER_ALTER ADD (ADDRESS VARCHAR2(100));

-- 새 컬럼 추가할 때 제약조건도 추가
ALTER TABLE TBL_USER_ALTER ADD (GENDER VARCHAR2(10) CHECK ( GENDER IN ('남', '여')));

-- 데이터가 있는 테이블에 컬럼을 추가할 때 주의.. NOT NULL 제약조건 설정 시 주의
ALTER TABLE TBL_USER_ALTER ADD(EMAIL VARCHAR2(50) DEFAULT 'NONE' NOT NULL );

-- 제약조건 추가
ALTER TABLE TBL_USER_ALTER ADD CONSTRAINT TBL_USER_ID_QU UNIQUE (USER_ID);
-- NOT NULL -> 추가가 안된다.. 컬럼 생성시 디폴트가 NULL 허용이라 기존 조건을 수정해야 함.
-- ALTER TABLE 테이블명 MODIFY 컬럼명 자료형 -> 컬럼 수정
-- ALTER TABLE 테이블명 MODIFY 컬럼명 CONSTRAINT 제약조건명 제약조건 -> 제약조건 수정
ALTER TABLE TBL_USER_ALTER MODIFY EMAIL CHAR(100);

-- ALTER TABLE 테이블명 DROP COLUMN 컬럼명 -> 컬럼 삭제하기
ALTER TABLE TBL_USER_ALTER DROP COLUMN EMAIL;

-- ALTER TABLE 테이블명 DROP CONSTRAINT 제약조건명 -> 제약조건 삭제
ALTER TABLE TBL_USER_ALTER DROP CONSTRAINT SYS_C007200;

-- ALTER TABLE 테이블명 RENAME COLUMN 수정전컬럼명 TO 수정후컬럼명 -> 컬럼명 수정
ALTER TABLE TBL_USER_ALTER RENAME COLUMN USER_ID TO USER_NICK;
ALTER TABLE TBL_USER_ALTER RENAME CONSTRAINT TBL_USER_ID_QU TO TBL_USER_NICK_QU;-- 제약조건명 수정

----------------------- 2021_03_15

-- DROP TABLE 테이블명 --> 참조되고 있는 테이블은 함부로 지울 수 없다.
CREATE TABLE REF_TEST(
    EMP_ID VARCHAR2(20) REFERENCES MEMBER(USER_ID),
    EMP_NAME VARCHAR2(20)
);

DROP TABLE MEMBER; --참조중인 테이블이라 삭제 불가
-- DROP TABLE 테이블명 CASCADE CONSTRAINTS; -- 제약조건 삭제하고 테이블 삭제

-- DCL : DATA에 대한 접근권한 설정. 권한 회수/트랜잭션 처리
-- GRANT. REVOKE : 권한부여, 회수
-- GRANT 권한명||ROLE명, 권한명,권한명,..... TO 사용자명
-- GRANT 권한명 ON 테이블 TO 사용자명 / 다른사용자 소유의 테이블 접근 가능하게 만들 수 있음

CREATE USER QWER IDENTIFIED BY QWER;
GRANT CREATE SESSION TO QWER;
GRANT CREATE TABLE TO QWER;
ALTER USER QWER DEFAULT TABLESPACE USERS;
ALTER USER QWER QUOTA UNLIMITED ON USERS;

-- 권한 확인하기
SELECT * FROM DBA_SYS_PRIVS
WHERE GRANTEE='QWER';

SELECT * FROM DBA_SYS_PRIVS
WHERE GRANTEE='KH';

SELECT * FROM USER_ROLE_PRIVS
WHERE USERNAME='KH';

--ROLE에 부여된 권한 확인
SELECT * FROM DBA_SYS_PRIVS
WHERE GRANTEE='RESOURCE';

CREATE ROLE MYROLE;
GRANT CREATE TABLE, CREATE SESSION TO MYROLE;

-- QWER 계정에 권한 부여해서 KH소유 테이블에 접근하게 하기
SELECT * FROM EMPLOYEE; -- 다른 계정 테이블 접속하는건 계정명.테이블명 으로 적어야 한다. 
SELECT * FROM KH.EMPLOYEE;  -- 이렇게

GRANT SELECT ON KH.EMPLOYEE TO QWER;

GRANT INSERT ON KH.EMPLOYEE TO QWER; -- KH.EMPLOYEE에 삽입할 권한을 QWER에게 준다~ 이말이다
INSERT INTO KH.EMPLOYEE (EMP_ID,EMP_NAME,EMP_NO,JOB_CODE,SAL_LEVEL) VALUES('888','GOM','999999-9999999','J5','S5');

-- 한번에 여러 권한 부여
GRANT SELECT, INSERT, UPDATE ON KH.DEPARTMENT TO QWER;

-- 부여된 권한 회수
REVOKE SELECT ON KH.EMPLOYEE FROM QWER;

CREATE TABLE TBL_USER(NAME VARCHAR2(20));

-- 트랜잭션 : 작업단위
SELECT * FROM TBL_USER;
GRANT SELECT ON KH.TBL_USER TO QWER;

-- VIEW : 가상의 테이블로, SELECT문 사용해서 실제 테이블의 데이터를 이용
-- VIEW도 하나의 ORACLE OBJECT 이라서 DDL로 생성 수정 삭제 가능
-- CREATE VIEW 뷰이름 AS SELECT문
CREATE VIEW  V_EMPALL AS SELECT * FROM EMPLOYEE
JOIN DEPARTMENT ON DEPT_CODE=DEPT_ID
JOIN JOB USING(JOB_CODE); -- VIEW에 대한 생성권한이 없어서 안됨.

GRANT CREATE VIEW TO KH; -- 권한부여 하면 위에 쿼리문 가능
SELECT*FROM V_EMPALL;

SELECT EMP_NAME, DEPT_TITLE, JOB_NAME, SALARY
FROM V_EMPALL;

UPDATE EMPLOYEE SET DEPT_CODE='D1' WHERE EMP_NAME='송종기'; -- 실제 테이블 수정시 뷰에도 반영됨.

CREATE VIEW V_EMP_AVG
AS SELECT DEPT_CODE, FLOOR(AVG(SALARY)) AS 평균
FROM EMPLOYEE
GROUP BY DEPT_CODE
UNION
SELECT JOB_CODE, FLOOR(AVG(SALARY)) AS 평균
FROM EMPLOYEE
GROUP BY JOB_CODE
UNION
SELECT '총평균', FLOOR(AVG(SALARY)) AS 평균
FROM EMPLOYEE;

-- VIEW 삭제
DROP VIEW V_EMPALL;

SELECT * FROM V_EMPALL;

-- OR REPLACE : 이미 그 이름의 VIEW가 있으면 덮어쓰기
CREATE OR REPLACE VIEW V_EMP
AS SELECT * FROM EMPLOYEE JOIN DEPARTMENT ON DEPT_CODE=DEPT_ID;

-- FORCE/NOFORCE : 실제테이블이 없어도 VIEW를 생성할 수 있게 함
CREATE FORCE VIEW V_TEMP
AS SELECT * FROM TT;

-- WITH CHECK OPTION : SELECT문에서 WHERE절에 사용한 컬럼은 수정못하게 하는 옵션
CREATE OR REPLACE VIEW V_EMP_SAL
AS SELECT EMP_NAME, DEPT_CODE, SALARY, SALARY*12 AS 연봉
FROM EMPLOYEE WHERE DEPT_CODE='D5' WITH CHECK OPTION; -- UPDATE로 수정 안됨.

-- SEQUENCE : 순차적으로 정수값을 자동으로 생성하는 객체
-- CREATE SEQUENCE 시퀀스명[옵션]
-- 시퀀스작동 예약어 : 시퀀스명.NEXTVAL / 시퀀스명.CURRVAL
CREATE SEQUENCE SEQ_BASIC;
SELECT SEQ_BASIC.NEXTVAL FROM DUAL;
SELECT SEQ_BASIC.CURRVAL FROM DUAL;

CREATE SEQUENCE SEQ_OPTION
START WITH 100
INCREMENT BY 10;

SELECT SEQ_OPTION.NEXTVAL FROM DUAL;

-- 조회할때마다 6이 늘어난다. 최대 500, 60시작
CREATE SEQUENCE SEQ_OPTION2
START WITH 60
INCREMENT BY 6
MAXVALUE 500
MINVALUE 0
CYCLE
NOCACHE;

SELECT SEQ_OPTION2.NEXTVAL FROM DUAL;

-- PK 값으로 설정하기
CREATE TABLE BOARD_SEQ(
BOARD_NO NUMBER PRIMARY KEY,
BOARD_TITLE VARCHAR2(200) NOT NULL,
BOARD_CONTENT VARCHAR2(800),
BOARD_WRITER VARCHAR2(20) REFERENCES EMPLOYEE(EMP_ID),
BOARD_DATE DATE
);

CREATE SEQUENCE SEQ_BOADE;
INSERT INTO BOARD_SEQ VALUES(SEQ_BOARD.NEXTVAL, '제목1', '내용1', '200', SYSDATE);
SELECT * FROM BOARD_SEQ;

-- SEQUNCE 를 사용할 수 없는 구문

-- INDEX : 전체적인 DBMS 성능향상을 위해 설정
-- CREATE [UNIQUE] INDEX 인덱스명 ON 테이블명(컬럼명, 컬럼명||함수계산식);
SELECT * FROM USER_INDEXES;

CREATE INDEX IND_EMPLOYEE ON EMPLOYEE(EMP_NAME);

DROP INDEX IND_EMPLOYEE;

-- 여러 컬럼에 인덱스 부여
CREATE INDEX IND_EMPLOYEE_COM ON EMPLOYEE(EMP_NAME, DEPT_CODE);

SET SERVEROUTPUT ON;
BEGIN
    DBMS_OUTPUT.PUT_LINE('첫 PL/SQL');
END;
/

-- 기본 익명블록
DECLARE
    V_ID VARCHAR2(20);
BEGIN
    SELECT EMP_ID
    INTO V_ID
    FROM EMPLOYEE
    WHERE EMP_NAME='선동일';

    DBMS_OUTPUT.PUT_LINE(V_ID);
END;
/

-- 변수 이용
-- 선언 : 변수명 자료형(길이);
-- 변수에 값 넣기 -> 변수명:=값
DECLARE
    V_EMPNO NUMBER;
    V_EMPNAME VARCHAR2(20);
    TEST_NUM NUMBER := 10+20; -- 선언과 동시에 초기화
BEGIN
    V_EMPNO := 300;
    V_EMPNAME := 'GOM';
    DBMS_OUTPUT.PUT_LINE(V_EMPNO);
    DBMS_OUTPUT.PUT_LINE(V_EMPNAME);
    DBMS_OUTPUT.PUT_LINE(TEST_NUM);
    END;
    /

-- 변수 자료형 알아보기
-- 기본자료형 : NUMBER, VARCHAR2, DATE, BOOLEAN, BINARY_INTEGER
-- 복합자료형 : 레코드, 커서, 컬렉션

-- 참조형 변수
-- %TYPE : 기존테이블에 있는 자료형을 참조해서 가져와 사용하는 것
DECLARE
    V_EMP_ID EMPLOYEE.EMP_ID%TYPE;
    V_SALARY EMPLOYEE.SALARY%TYPE;
BEGIN
    SELECT EMP_ID, SALARY
    INTO V_EMP_ID, V_SALARY
    FROM EMPLOYEE
    WHERE EMP_ID='&사원명';
    DBMS_OUTPUT.PUT_LINE(V_EMP_ID||V_SALARY);
END;
/

-- 레코드 : 클래스
DECLARE
    TYPE MY_RECORD IS RECORD(
        V_ID EMPLOYEE.EMP_ID%TYPE,
        V_NAME EMPLOYEE.EMP_NAME%TYPE,
        V_DEPTTITLE DEPARTMENT.DEPT_TITLE%TYPE
    );
    MY_VAR MY_RECORD;
BEGIN
    SELECT EMP_ID, EMP_NAME, DEPT_TITLE
    INTO MY_VAR
    FROM EMPLOYEE
    JOIN DEPARTMENT ON DEPT_CODE=DEPT_ID
    WHERE EMP_ID='&사원번호';

    DBMS_OUTPUT.PUT_LINE(MY_VAR.V_ID||' '||MY_VAR.V_NAME||' '||MY_VAR.V_DEPTTITLE);
END;
/

--------------------------- 2021_03_16

-- TABLE 타입 선언
DECLARE
    TYPE EMP_ID_TABLE_TYPE IS TABLE OF EMPLOYEE.EMP_ID% TYPE
    INDEX BY BINARY_INTEGER;

    V_EMPID EMP_ID_TABLE_TYPE;
    I BINARY_INTEGER:=0;
BEGIN
    FOR K IN (SELECT EMP_ID FROM EMPLOYEE) LOOP
        I:=I+1;
        V_EMPID(I):=K.EMP_ID;
    END LOOP;

    FOR K IN 1..I LOOP
        DBMS_OUTPUT.PUT_LINE(V_EMPID(K));
    END LOOP;
END;
/
SET SERVEROUTPUT ON;

-- PL/SQL 구문에서 SELECT문 처리
-- ㄴ 반드시 INTO 사용해야 한다.
DECLARE
    V_EMP_ID EMPLOYEE.EMP_ID%TYPE;
BEGIN
    SELECT EMP_ID
    INTO V_EMP_ID
        FROM EMPLOYEE
        WHERE EMP_NAME='&이름';
END;
/

SELECT * FROM INSERTEST;
CREATE TABLE INSERTEST(
 VAL VARCHAR2(500)
);
-- PL/SQL 에서 INSERT문 처리
BEGIN
    INSERT INTO INSERTEST VALUES ('PL/SQL문으로 입력하기');
    COMMIT;
end;
/
--반복문
BEGIN
    FOR K IN 1..10 LOOP
        INSERT INTO INSERTEST VALUES ('PL/SQL문으로 입력하기');
        COMMIT;
    END LOOP;
end;
/

--1. 사원 번호를 입력받아 받은 사원의 사원번호, 이름, 부서코드, 부서명을 출력

--2. 사원번호를 입력받아서 해당 사원의 정보(한 행)를 한 변수에 모두 입력받아
--  사번, 이름, 주민번호, 급여를 출력하여라

--3. EMPLOYEE 테이블에서 사번 마지막 번호를 구한 뒤, +1한 사번에 사용자로 부터 입력받은
-- 이름, 주민번호, 전화번호, 직급코드(J5), 급여등급(S5)를 등록하는 PL/SQL을 작성하자.
DECLARE
    ID EMPLOYEE.EMP_ID%TYPE;
BEGIN
    SELECT MAX(EMP_ID)
        INTO ID
    FROM EMPLOYEE WHERE EMP_ID LIKE'2%'; -- 200번대
    INSERT INTO EMPLOYEE(EMP_ID, EMP_NAME, EMP_NO, PHONE, JOB_CODE, SAL_LEVEL)
        VALUES(ID+1,'&이름','&주민번호','&전화번호','&직책코드','&급여코드');
    DBMS_OUTPUT.PUT_LINE(ID);
end;
/

-- 사번을 입력받아 이름을 조회하고 그 이름이 선동일이면 ' 난 대표다 ! ' 출력
DECLARE
    V_EMPNAME EMPLOYEE.EMP_NAME%TYPE;
BEGIN
    SELECT EMP_NAME
    INTO V_EMPNAME
    FROM EMPLOYEE
    WHERE EMP_ID='&사원아이디'
    
    IF V_EMPNAME='선동일' 
        THEN DBMS_OUTPUT.PUT_LINE('난 대표다!');
END;
/
-- IF THEN ELSE END IF;
-- 조회된 사원이 선동일이면 난 대표다! 아니면 난 사원이다!
DECLARE
    V_EMPNAME EMPLOYEE.EMP_NAME%TYPE;
BEGIN
    SELECT EMP_NAME
    INTO V_EMPNAME
    FROM EMPLOYEE
    WHERE EMP_ID='&사원아이디';
    IF V_EMPNAME='선동일' 
        THEN DBMS_OUTPUT.PUT_LINE('난 대표다!');
    ELSE DBMS_OUTPUT.PUT_LINE('난 사원이다~');
    END IF;
END;
/

-- IF THEN~ ELSIF THEN ~ ELSE ~ END IF;
-- 직책코드가 J1이면 대표다! J2 면 임원이다. 그외면 사원이다 출력
SET SERVEROUTPUT ON;

DECLARE
    V_JOBCODE EMPLOYEE.JOB_CODE%TYPE;
BEGIN
    SELECT JOB_CODE
    INTO V_JOBCODE
    FROM EMPLOYEE
    WHERE JOB_CODE='&직책코드';
    
    IF V_JOBCODE = 'J1' THEN
        DBMS_OUTPUT.PUT_LINE('난 대표다!');
        ELSIF V_JOBCODE = 'J2' THEN
            DBMS_OUTPUT.PUT_LINE('난 임원이다');
        ELSE DBMS_OUTPUT.PUT_LINE('사원이다');
    END IF;
END;
/

DELETE FROM EMPLOYEE
WHERE EMP_NAME='DAS';

SELECT * FROM EMPLOYEE;

-- CASE문으로 월급 400이상이면 고액, 200이상 평타, 그 이하면 ㅠㅠ 출력
DECLARE
    V_SALARY EMPLOYEE.SALARY%TYPE;
BEGIN
    SELECT SALARY
    INTO V_SALARY
    FROM EMPLOYEE
    WHERE EMP_ID='&사번';
    
    CASE
        WHEN V_SALARY>=4000000 THEN DBMS_OUTPUT.PUT_LINE('고액');
        WHEN V_SALARY>=2000000 THEN DBMS_OUTPUT.PUT_LINE('평타');
        ELSE DBMS_OUTPUT.PUT_LINE('ㅠㅠ');
    END CASE;
END;
/

-- LOOP
-- LOOP~ 실행할구문 END LOOP -> 무한루프
-- 실행할 구문에서 빠져나오는 예약어 : EXIT

-- 1~10 출력하기
DECLARE
    I NUMBER :=1;
BEGIN
    LOOP
        DBMS_OUTPUT.PUT_LINE(I);
        I := I+1;
        IF I>10 THEN EXIT;
        END IF;
    END LOOP;
END;
/

-- FOR문
-- FOR 변수 IN 범위||SELECT문 LOOP
-- 실행구문
-- 범위시작숫자..끝숫자
-- END LOOP;

BEGIN
    FOR I IN 1..10 LOOP
        DBMS_OUTPUT.PUT_LINE(I);
    END LOOP;
END;
/

-- ㄴ 거꾸로
BEGIN
    FOR I IN REVERSE 1..10 LOOP
        DBMS_OUTPUT.PUT_LINE(I);
    END LOOP;
END;
/

-- EMPLOYEE에 있는 10개의 ROW출력
-- EMP_ID 200~209
DECLARE
    E EMPLOYEE%ROWTYPE;
    V_EMP_ID EMPLOYEE.EMP_ID%TYPE;
BEGIN
    V_EMP_ID:=200;
    FOR I IN 1..10 LOOP
        SELECT*
        INTO E
        FROM EMPLOYEE
        WHERE EMP_ID=V_EMP_ID;
        V_EMP_ID:=V_EMP_ID+1;
        DBMS_OUTPUT.PUT_LINE(E.EMP_ID||E.EMP_NAME);
    END LOOP;
END;
/

-- %TYPE 
--형식=> 변수명  테이블명.칼럼명%TYPE ;    
--(기존 테이블의 칼럼에 선언된 데이터타입과 크기를 참조하여 변수를 선언
--테이블 칼럼의 제약조건은 적용되지 않음.)

-- %ROWTYPE
-- 변수명   테이블명%ROWTYPE ;
-- 기존 테이블의 각 칼럼에 정의된 데이터타입과 크기를 참조
-- 칼럼 수와 동일한 복수 개의 변수가 선언,
-- 각 기억 장소의 구분은 “변수명.칼럼명”으로 구분

-- 프로시저 : 특정 처리 작업을 수행하는데 사용하는 저장 서브프로그램

-- 프로시저 생성
--CREATE [OR REPLACE] PROCEDURE 프로시저명
--IS | AS
--선언부
--BEGIN
--실행부
--END;

-- 프로시저 실행 
-- EXECUTE 프로시저명; (SET SERVEROUTPUT ON; 필요)

-- 등록된 프로시저 조회
SELECT * FROM USER_PROCEDURES;

-- 매개변수 있는 프로시저 생성
-- IN : 프로시저 실행 시 필요한 값을 받는 변수 (일반 매개변수 개념)
-- OUT :프로시저가 실행한 결과를 되돌려주는 변수

-- CREATE OR REPLACE PROCEDURE PRO_SELECT_EMP(V_EMP IN EMPLOYEE.EMP_ID%TYPE,

-- FUNCTION : 프로시저와 유사. RETURN 값이 있다.
CREATE OR REPLACE FUNCTION MYFUNC(STR VARCHAR2)
RETURN VARCHAR2
IS
    RESULT VARCHAR2(10000);
BEGIN
    RESULT := '앞'||STR||'뒤';
    RETURN RESULT;
END;
/

SELECT MYFUNC ('GOM') FROM DUAL;

-- EMP_ID를 전달받아 연봉을 계산해서 출력해주는 함수
CREATE OR REPLACE FUNCTION CALC(V_EMP_ID EMPLOYEE.EMP_ID%TYPE)
RETURN NUMBER
IS
    E EMPLOYEE%ROWTYPE;
    RESULT NUMBER;
BEGIN
    SELECT *
    INTO E
    FROM EMPLOYEE
    WHERE EMP_ID=V_EMP_ID;
    RESULT := (E.SALARY+E.SALARY*NVL(E.BONUS,0))*12;
    RETURN RESULT;
END;
/

SELECT CALC(201) FROM DUAL;

SELECT EMP_ID, EMP_NAME, SALARY, CALC(EMP_ID)
FROM EMPLOYEE;

--트리거 이용하기
-- 특정테이블에  DML구문이 실행될 때(전,후) 특정한 로직이 수행되도록하는 것
-- CREATE OR REPLCAE TRIGGER 트리거명칭
-- 실행시점(AFTER/BEFORE) DML구문(INSERT,UPDATE,DELETE)
-- FOR EACH ROW 
-- BEGIN ~~~ PL/SQL구문 작성

CREATE OR REPLACE TRIGGER TRG_01
AFTER INSERT
ON EMPLOYEE
FOR EACH ROW
BEGIN
    DBMS_OUTPUT.PUT_LINE('신입사원이 입사하였습니다');
END;
/

INSERT INTO EMPLOYEE VALUES (908, '길성춘', '690512-1151432','gil_sj@kh.or.kr', 
                    '01035464455', 'D5', 'J3', 'S5', 3000000, 0.1, 200, SYSDATE, NULL,
			       DEFAULT);

-- 데이터가 조작된 전/후
-- 이전, 이후자료
--               :NEW.컬럼명(새로운값) / :OLD.컬럼명(이전값)
-- UPDATE               O                                O
-- INSERT               O                                X
-- DELETE               X                                O

CREATE OR REPLACE TRIGGER TRG_02
AFTER UPDATE
ON EMPLOYEE
FOR EACH ROW
BEGIN
    DBMS_OUTPUT.PUT_LINE(:OLD.EMP_NAME);
    DBMS_OUTPUT.PUT_LINE(:OLD.SALARY);
    DBMS_OUTPUT.PUT_LINE(:NEW.EMP_NAME);
    DBMS_OUTPUT.PUT_LINE(:NEW.SALARY);
END;
/
    
UPDATE EMPLOYEE SET EMP_NAME='김가현', SALARY=500 WHERE EMP_ID='888';


--재고관리 테이블에 트리거 적용하기
CREATE TABLE PRODUCT(
    PCODE NUMBER PRIMARY KEY,
    PNAME VARCHAR2(30),
    BRAND VARCHAR2(30),
    PRICE NUMBER,
    STOCK NUMBER DEFAULT 0
);
--상품의 입출고를 관리하는 테이블
CREATE TABLE PRODUCT_IO(
    IOCODE NUMBER PRIMARY KEY,
    PCODE NUMBER CONSTRAINT FK_PRO_NAME REFERENCES PRODUCT(PCODE),
    PDATE DATE,
    AMOUNT NUMBER,
    STATUS VARCHAR2(10) CHECK(STATUS IN('입고','출고'))
);
CREATE SEQUENCE SEQ_PRO;
CREATE SEQUENCE SEQ_IO;

INSERT INTO PRODUCT VALUES(SEQ_PRO.NEXTVAL,'보호필름','아르마니',500000,DEFAULT);
INSERT INTO PRODUCT VALUES(SEQ_PRO.NEXTVAL,'갤럭시폴드','삼성',2300000,DEFAULT);
INSERT INTO PRODUCT VALUES(SEQ_PRO.NEXTVAL,'카누','동서식품',120000,DEFAULT);
INSERT INTO PRODUCT VALUES(SEQ_PRO.NEXTVAL,'콜라뽑기','불량식품',1000,DEFAULT);

SELECT * FROM PRODUCT;

--입출고테이블에 입고, 출고가 됐을때 TRIGGER를 이용해서 PRODUCT테이블을 수정해보자
CREATE OR REPLACE TRIGGER TRG_IO
AFTER INSERT
ON PRODUCT_IO
FOR EACH ROW
BEGIN 
    IF :NEW.STATUS ='입고' THEN
        UPDATE PRODUCT SET STOCK=STOCK+:NEW.AMOUNT WHERE PCODE=:NEW.PCODE;
     ELSIF :NEW.STATUS='출고' THEN
        UPDATE PRODUCT SET STOCK=STOCK-:NEW.AMOUNT WHERE PCODE=:NEW.PCODE;
    END IF;
END;
/
INSERT INTO PRODUCT_IO VALUES(SEQ_IO.NEXTVAL, 1,SYSDATE,100, '입고');
INSERT INTO PRODUCT_IO VALUES(SEQ_IO.NEXTVAL, 2,SYSDATE,5, '입고');
INSERT INTO PRODUCT_IO VALUES(SEQ_IO.NEXTVAL, 1,SYSDATE,10, '출고');
SELECT * FROM PRODUCT;
SELECT * FROM PRODUCT_IO;



