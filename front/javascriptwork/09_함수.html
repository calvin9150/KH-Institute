<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>함수이용하기</title>
</head>
<body>
    <h2>함수선언하기</h2>
    <ul>
        <li>
            <p>선언적함수 : 선언시에 함수명을 작성하는 함수</p>
            <p>function 함수명([매개변수,....]){처리로직} *매개변수는 변수명만 작성</p>
        </li>
        <li>
            <p>익명함수 : 선언시에 함수명을 작성하지 않는 함수</p>
            <p>function ([매개변수,....]){처리로직}</p>
            <p>익명함수를 이용하려면 변수(일반변수, 매개변수)에 반드시 대입해야한다.</p>
        </li>
    </ul>
    <h2>선언적함수</h2>
    <p>
        선언된 이름을 이용하여 함수를 호출할 수 있음
        window객체의 함수명이 property로 등록이 됨.
    </p>
    <script>
        //매개변수 있고 반환값이 없는 함수
        function basicFunc(){
            console.log("basic",arguments);
            console.log("난 매개변수도 반환도 없는 함수야");
        }
        //함수호출하기
        basicFunc();

        //매개변수있고 반환형 없는 함수
        //매개변수선언은 let, var예약어 없이 이름만 명시한다.
        //다수일때는 ,로 구분한다.
        function paramFunc(name, age){
            console.log("param",arguments);
            for(let i=0;i<arguments.length;i++){
                console.log(arguments[i]);
            }
            if(arguments.length>=2&&typeof(arguments[0])=="string"&&typeof(arguments[1])=="number"){
                //console.log("이름 : "+name+" 나이 : "+age);
                console.log(`${name} ${age}`);
                
                if(typeof(age)=="number"){
                    console.log(`이름 : ${name} 나이 : ${++age}`);
                }else{
                    console.error("두번째 매개변수는 숫자로 입력하세요!");
                }
            }else{
                throw new Error("잘못되 인수가 처리되었습니다");
            }
        }
        //매개변수의 자료형에 상관없이 사용이 가능하다.
        // paramFunc("유지훈", 49);
        // paramFunc(19,"유병승");

        //함수에 선언되 매개변수 갯수보다 적게 호출하면 어떻게 될까?
        // paramFunc("정우영");
        // paramFunc();

        //함수에 선언된 매개변수보다 더 많은 매개변수 보내기
        // paramFunc("박원재",48,"won@won.com","01012341234");
        // basicFunc(1,2,3,4,5,6,7,8,9);

        //function마다 호출시 보내는 매개변수를 보관하는 객체를 만들어놨음!
        //arguments객체

        //반환형이 있는 선언적함수
        //{}안 return이 있으면 반환이 있는 함수
        //없으면 없는 함수
        function returnTest(){
            return [1,2,3,4,5];
        }
        let arr=returnTest();
        console.log(arr);


        //반환형이 있고 매개변수가 있는 함수
        function returnParam(v,v1,v2,v3,v4){
            return [v,v1,v2,v3,v4];
        }
        let temp=returnParam(1,2,3,4,5);
        console.log(temp);
        temp=returnParam("유병승","유지훈","김기영","장우영","김가현");
        console.log(temp);

        //선언함수로 선언된 함수는 window객체에 property로 선언되어있음
        console.log(window);



        //선언함수의 이름을 중복으로 선언을 한다면?? 
        //덮어쓰기가됨! ->       
        // function returnParam(){
        //     return "머선129"; 
        // }
        //console.log(bs);
        console.log(returnParam1);
        //temp=returnParam1();

        var returnParam1=function(){
            return "머선129";
        }
        
        temp=hoistingTest();
        console.log(temp);

        function hoistingTest(){
            return "이얏~!";
        }
        // const returnParam=function(){

        // };
    </script>

    <h2>익명함수 활용하기</h2>
    <p>
        익명함수는 변수(일반변수, 매개변수)에 대입해서 사용을 한다.
        함수를 호출할때는 함수명으로 호출해야하는데 선언시 호출할 명칭을 선언하지 않기 때문에...
        callback함수로 많이 사용함(매개변수로 함수를 넣는 것)
        스스로 동작함수구현시.
    </p>
    <script>
        //매개변수가 없고 반환형이 없는 함수선언
        let annoFunc=function(){
            console.log('난 아무것도 없다!');
        }
        annoFunc();
        console.log(annoFunc);
        //매개변수있고 반환형없는 함수
        annoFunc=function(su, su2){
            console.log(`더하기 : ${su+su2}`);

        }
        annoFunc(10,20);


        annoFunc=function(su,su2){
            return su+su2;
        }
        let result=annoFunc(10,10);
        console.log(result);

        //익명함수도 arguments가 있을까?? 쓸수있따.!
        let arguTest=function(){
            console.log(arguments);
        }
        arguTest(1,2,3,4,5,6,7);


        //hoisting -> 저장소를 먼저 확보하여 호출가능하게 하는 건
        //선언되기전 함수, 변수를 호출할 수 있게 하는 기능
        
        let test=function(){
            console.log("test함수","hoisting");
        }

        test();
       // testHoisting();
        
        let testHoisting=function(){
            console.log("testHoisting함수","난 익명함수야!");
        }
        
        // function test(){
        //     console.log("test함수","hoisting");
        // }
        let test1=function(){
            console.log("덮어써지니?");
        }
        // function test(){
        //     console.log("덮어써지니??");
        // }
        test1();

        test1=function(){
            console.log("하하하하 지훈이가 바꿈...누가 찾을 수 있을까?");
        }
        test1();

        //통상적으로 함수는 변경하지 않고 고정해서 사용하기 때문에 변경할 수 없는 const를 사용하는게 안정적임

        const finalFunc=function(){
            console.log("이건 변경 못하지롱");
        }
        finalFunc();
        
        // finalFunc=function(a,b,c){
        //     console.log("하하하 지훈이가 변경할꺼지롱!");
        // }

    </script>


    <h2>callback함수로 이용하기</h2>
    <p>
        매개변수로 함수를 전달하는것
        기본제공함수, 이벤트핸들링(처리) 많이 사용을 함.
    </p>
    <ul>
        <li class="test">1</li>
        <li class="test">2</li>
        <li class="test">3</li>
        <li class="test">4</li>
    </ul>    

    <script>
        // li태그에 이벤트 연결하기
        let lis=document.getElementsByClassName("test");
        for(let i=0;i<lis.length;i++){
            lis[i].addEventListener("click",function(){
                this.innerHTML+="클릭함";//this : 이벤트가 발생한 객체임!
            });
        }
        //기본  window가 제공하는 함수
        setTimeout(function(){
            //alert("0.5초후 실행!");
        },500);

        //callback함수는 꼭 익명함수만 사용해야하는 것은 아님.
        function callbackTest(){
            //alert("호호호호");
        }
        setTimeout(callbackTest,1000);

    </script>

    <h2>함수리턴하기</h2>
    <p>
        함수는 자료형을 사용하기 때문에 리턴도 가능
    </p>
    <script>
        const returnFunc=function(){
            return function(){
               // alert("반환된함수");
            }
        }

        //반환받은함수를 호출하기
        let returnFuncExec=returnFunc();
        console.log(returnFuncExec);
        //returnFuncExec();
        //한번에 실행하기
        returnFunc()();
    </script>


    <h2>클로저의 개념</h2>
    <p>
        자신을 내포하는 함수의 컨텍스트에 접근할 수 있는 함수<br>
        함수가 특정스코프에 접근할 수 있도록 의도적으로 그 스코프에서 정의하는것<br>
        함수을 선언할때 만들어지는 유효범위가 사라진 후에도 호출할 수 있는 함수
    </p>
    <script>
        const basicClosure=function(){
            let name="";
            return function(addName){
                name+=addName;
                console.log(`누적 : ${name}  신규 : ${addName}`);
            }
        }
        let closureTest=basicClosure();
        console.log(closureTest);

        closureTest("유병승");
        closureTest("김기영");
        closureTest("노상민");

        closureTest=null;

        //console.log(name);

        //매개변수를 이용하는 방법
        const basicClosure2=function(dinner){
            return function(addSub){
                dinner+=" "+addSub;
                console.log(dinner);
            }
        }
        closureTest=basicClosure2("계란초밥");
        closureTest("간장");
        closureTest("락교");
        let flag=true;
        const basicClosure3=function(flag){
            return function(){
                let le=document.getElementById("targetToggle");
                if(flag){
                    le.style.backgroundColor="lime"
                    flag=!flag;
                }else{
                    le.style.backgroundColor="white";
                    flag=!flag;
                }
            }
        }
        flag=false;
        const targetFunc=basicClosure3(true);
    </script>
    <h2 id="targetToggle" onclick="targetFunc();">이거변경하기</h2>

    <button id="btn">증가하기</button>
    <script>
        document.getElementById("btn").addEventListener("click",function(){
            let count=0;
            let span=document.createElement("span");
            span.innerHTML="click";
            span.addEventListener("click",function(){
                this.innerHTML=`${count++}번 누름`;
            });
            document.getElementById("btn").insertAdjacentElement("afterend",span);
        });
    </script>

    <h2>ES6에서 함수표현식</h2>
    <p>
        arrow함수라고 함 화살표함수 * 람다와유사()->{}
        익명함수를 표현할때 더 간결하게 표현할 수 있는 함수
        ([매개변수])=>{ 로직 [return 값]}

        1. this값이 무조건 window를 바라보게됨.
        2. arguments객체를 사용할 수 없음
        3. 객체의 매소드를 선언시에는 사용하지말 것
    </p>

    <script>
        const arrowFunc=()=>{
            console.log("화살표함수임");
        }
        arrowFunc();
        //매개변수 있는 화살표함수
        const arrowFunc2=(name, age)=>{
            console.log(arguments);
            console.log(`이름 : ${name} 나이 : ${age}`);
        }
        arrowFunc2("김기영",49);
        arrowFunc2("김기영",49,1,23,4,5,6);

        //return값 있는 화살표함수
        const arrowFunc3=()=>{
            return "하하 화살표함수!";
        }
        arrowFunc3="asdfa";
        let temp1=arrowFunc3();
        console.log(temp1);

    </script>
    <button id="btn2">실행</button>
    <div id="targetArrow"></div>
    <script>
    //이벤트핸들러에 화살표함수넣기
        let b=document.getElementById("btn2");
        b.addEventListener("click",function(){//()=>{
            console.log(this);//이벤트가 발생한객체가 아니라 window객체임.
            let t=document.getElementById("targetArrow");
            t.innerHTML+="<h3>화살표함수 실행</h3>";
        });
    </script>    

</body>
</html>